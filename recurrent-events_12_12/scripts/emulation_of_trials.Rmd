---
title: "Estimation of Causal Effect via Emulation of RCTs"
author: "Quinn White"
date: "`r Sys.Date()`"
output: 
  rmdformats::readthedown:
    code_folding: hide
knit: (function(input,...) {
  rmarkdown::render(input,output_dir=here::here("output"))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE, warning=FALSE,error=TRUE)

library(tidyverse)
library(here)
library(survey)
theme_c <- function(...){ 
   # font <- "Helvetica"   #assign font family up front
  #  font <- "Arial"
    theme_bw() %+replace%    #replace elements we want to change
    
    theme(
      
      #text elements
      plot.title = element_text(             #title
                 #  family = font,            #set font family
                   size = 11,                #set font size
                   face = 'bold',            #bold typeface
                   hjust = .5,
                   vjust = 3),               
      
      plot.subtitle = element_text(          #subtitle
                #   family = font,            #font family
                   size = 10,
                   hjust = .5,
                   face = 'italic',
                   vjust = 3),               #font size
      
      axis.title = element_text(             #axis titles
                #   family = font,            #font family
                   size = 10),               #font size
      
      axis.text = element_text(              #axis text
                #   family = font,            #axis famuly
                   size = 8),
      strip.text = element_text(color="white", size = 9,
                                margin=unit(c(.1,.1,.1,.1), 'cm')),
      strip.background = element_rect(fill = "#363636"),
      # t, r, b, l
      plot.margin = unit(c(1,.5,.5,.5), "cm")
      ) %+replace%
      theme(...)
   
}



```

# Set-Up 

```{r simulation-functions-biweekly}

get_X_at_k <- function(time_point, dat, n_packs) {
  # L_{k-1}
  X_prev <- dat %>% pull(paste0("X", time_point-1))
  # A_{k}
  A1_prev <- dat %>% pull(paste0("A", time_point-1, "_1"))
  # Y_{k} 
  Y_prev <- dat %>% pull(paste0("Y", time_point-1))
  
  # wolves previously - wolves killed + term (adding or subtracting one)
  # accounting for death/birth
  # more likely to be birth if Y_prev was 1 (well fed)
  # term accounting for death/birth more likely to be positive 
  
  prob_birth <- ifelse(Y_prev == 1, .7, .5)
  
  X_new <- X_prev - A1_prev + 2*rbinom(n_packs, size=1, prob_birth) - 1
  
  # if pack is less than 3 already, only stay the same or grow 
  X_new <- ifelse(X_new <= 3, X_prev + 
                  rbinom(n_packs, size=1, prob=.5), 
                  X_new)

  Xname <- paste0("X", time_point)
  
  return(dat %>% 
           bind_cols(tibble(!!Xname := X_new))
         )
}

get_outcome_at_k <- function(time_point, dat, n_packs,
                             interval_length, 
                             lambda_0=8) {
  
    # Y_{k-1}
    Y_prev <- dat %>% pull(paste0("Y", time_point-1))
    
    # X_k
    X_prev <- dat %>% pull(paste0("X", time_point))
    
     # W_k
    W_prev <- dat %>% pull(paste0("W", time_point))
    
    # most recent wolf removal 
    most_recent_treatment <- dat %>% 
      mutate(most_recent = ifelse(
      rowSums(select(., matches("A*_1"))) == 0,
           0, max.col(select(., matches("A*_1")),
                      ties.method="last"))) %>%
      pull(most_recent)
    
    A1_prev <- ifelse(most_recent_treatment==0, 0, 1)
    
    # most recent depredation event
    most_recent_depredation_event <- dat %>% 
      mutate(most_recent = ifelse(
      rowSums(select(., matches("Y"))) == 0,
           NA, max.col(select(., matches("Y")),
                      ties.method="last"))) %>%
      pull(most_recent)


    # 1. Extract A*_1 columns into a matrix
    Amat <- dat %>%
      select(matches("^A[0-9]+_1$")) %>%
      as.matrix()
    
    # 2. Helper to get k-th most recent (k=1,2,3,...)
    get_kth_most_recent <- function(x, k) {
      idx <- which(x == 1)
      if (length(idx) < k) return(NA)  # or NA_integer_ if you prefer
      sort(idx, decreasing = TRUE)[k]
    }
    
    # 3. Apply rowwise over the matrix
   # most_recent_treatment  <- apply(Amat, 1, get_kth_most_recent, k = 1)
   #  cat(all(most_recent_treatment==most_recent_treatment_new))

    second_most_recent_treatment <- apply(Amat, 1, get_kth_most_recent, k = 2)
    third_most_recent_treatment  <- apply(Amat, 1, get_kth_most_recent, k = 3)
    
    # delay is time from most recent treatment to current time 
    # if treatment has happened 
    # treatment only effective if happened after dep event 
    # delay <- ifelse(most_recent_treatment != 0 &
    #                   most_recent_depredation_event <= most_recent_treatment, 
    #                 (time_point - most_recent_treatment),
    #                 NA) 
    # 
    # delay_2 <- ifelse(second_most_recent_treatment != 0 &
    #                   most_recent_depredation_event <= second_most_recent_treatment, 
    #                 (time_point - second_most_recent_treatment),
    #                 NA) 
    # delay_3 <- ifelse(third_most_recent_treatment != 0 &
    #                   most_recent_depredation_event <= third_most_recent_treatment, 
    #                 (time_point - third_most_recent_treatment),
    #                 NA) 
    
    
    delay <- ifelse(most_recent_treatment != 0 &
                      most_recent_depredation_event <= most_recent_treatment, 
                    (most_recent_treatment - most_recent_depredation_event),
                    NA) 
    
    delay_2 <- ifelse(second_most_recent_treatment != 0 &
                      most_recent_depredation_event <= second_most_recent_treatment, 
                    (second_most_recent_treatment - most_recent_depredation_event),
                    NA) 
    delay_3 <- ifelse(third_most_recent_treatment != 0 &
                      most_recent_depredation_event <= third_most_recent_treatment, 
                    (third_most_recent_treatment - most_recent_depredation_event),
                    NA) 
    
    # cat(most_recent_treatment,
    #     second_most_recent_treatment,
    #     third_most_recent_treatment,
    #     delay, delay_2, delay_3, "\n")
    
   A2_prev <- delay
   


   A2_effect <- case_when( is.na(A2_prev) ~ 0,
                           A2_prev == 0 ~ 4,
                           A2_prev  == 1 ~ 3,
                           A2_prev == 2  ~ 2,
                           A2_prev >= 3 ~ 0)
   
   # if second treatment is one after time point, has effect 
   A2_effect_2 <- case_when( is.na(delay_2) ~ 0,
                           delay_2 == 0 ~ 0,
                           delay_2 == 1 ~ 0,
                           delay_2  == 2  ~ 0,
                           delay_2 >= 3 ~ 0)
   # if third treatment is two after time point, has effect 
   A2_effect_3 <- case_when( is.na(delay_3) ~ 0,
                           delay_3 == 0 ~ 0,
                           delay_3 == 1 ~ 0,
                           delay_3  == 2  ~ 0,
                           delay_3 >= 3 ~ 0)
    

   # cat("Most recent event=", most_recent_depredation_event,
   #     "Most recent treatment=", most_recent_treatment,
   #     ", treatment delay=", A2_prev, ", effect=", A2_effect, "\n")

    prob_event <- plogis(

      (-9 + 
        #bigger pack -> more mouths to feed
        2.7*(X_prev/sqrt(lambda_0))
        # more likely to kill if killed before 
        +2*ifelse(Y_prev==1, 1.1, 1)  
       - 10*A2_effect # - 6*A2_effect_2 - 1 * A2_effect_3
        # behavioral effect - stronger effect if delay is small 
        #- 20 * A1 - 10 * A_lag1 - 2 * A_lag2
        #- 1.1 * A1*A_lag1 - 1.1 * A_lag2*A_lag1 - 1.1 * A1* A_lag2
        - 5 * W_prev
       )
        * .05 )*(plogis(interval_length)^8)*1.1

    Y_new <- rbinom(n_packs, size=1, prob=prob_event)
    Yname <- paste0("Y", time_point)

    dat %>% 
      bind_cols(tibble(
        !!Yname := Y_new))
}


# assumes time point is in weeks 
get_W_at_k <- function(time_point, dat, n_packs, interval_length) {
  week <- time_point*interval_length
  if(time_point*interval_length >= 52)  {
    week <- time_point*interval_length - 52
  } 
  if(week < 8 | week > 12*4){
    W <- rep(1, nrow(dat))
  } else {
    W <- rep(0, nrow(dat))
  }
    Wname <- paste0("W", time_point)
    
    dat %>% bind_cols(tibble(!!Wname := W))
  
}

# adds treatments Ak_1, Ak_2, Ak_3 to input data frame dat 
get_treatment_at_k <- function(time_point, dat, n_packs,
                               interval_length=8,
                               intervention=NULL,
                               lambda_0=8,
                               poach_harvest_only=TRUE) {
  
  # X_{k}, Y_{k}
  X_prev <- dat %>% pull(paste0("X", time_point))
  Y_prev <- dat %>% pull(paste0("Y", time_point))
  W_prev <- dat %>% pull(paste0("W", time_point))
 
  if(!poach_harvest_only){
    prob_treat <- plogis(-6.5 + 2*Y_prev + .7*(X_prev)/sqrt(lambda_0) 
                         - .5* W_prev
                           # +rnorm(n_packs,0,3)
                         )*(plogis(interval_length)^(7))*1.05
  } else{
      prob_treat <- plogis(-6 +.7*(X_prev)/sqrt(lambda_0) 
                           - .5* W_prev  
                            # + rnorm(n_packs,0,3)
                           )*(plogis(interval_length)^(7))*1.3
  }
  

  A11 <- rbinom(n_packs, 
                size=1, 
                prob=prob_treat)

  # breeding female = 2/pack_size (larger for smaller packs)
  # prob = 0 if A11=0

  if (!is.null(intervention)) {
      assigned <- intervention(dat, time_point, current_a=A11)
      A11 <- assigned %>% pull(A1)
    }

  
  y_cols_to_check <- 1:time_point
  
  y_cols_to_check <- paste0("Y", y_cols_to_check)

  
  name1 <- paste0("A", time_point, "_1")
 
  dat %>% 
    bind_cols(tibble(
      !!name1 := A11
      ))

}

```

# Clinical Trial Setup 

```{r run-trial}

# assumes time point is in weeks 
get_W_at_k_trial <- function(time_point, true_time, dat, n_packs, interval_length) {
  
  week <- true_time*interval_length
  if(true_time*interval_length >= 52)  {
    week <- true_time*interval_length - 52
  } 
  if(week < 8 | week > 12*4){
    W <- rep(1, nrow(dat))
  } else {
    W <- rep(0, nrow(dat))
  }
    Wname <- paste0("W", time_point)
    
    dat %>% bind_cols(tibble(!!Wname := W))
  
}


# for simplicity, suppose study start is in January 
# intervention must be a function that outputs A1, A2 (assigned treatments) 
# takes in the natural value of treatment (so can be a shift intervention)
run_trial <- function(weeks=16, n_packs=5,
                           interval_length=8, 
                           intervention=NULL) {
  
  # 2 week intervals
  K <- round(weeks/interval_length)
  
  #----------------------------------------------------------------
  # Baseline covariates: number of wolves in pack at study start 
  #----------------------------------------------------------------
  lambda_0 <- 8 
  X1 <- rpois(n_packs, lambda_0)
  # winter -> cows close to home -> safer 
  # calendar start date
  trial_start <- sample(size=1, 1:26)

  # first depredation event
  # prob_event <- plogis(-4 + .3*(L0)/sqrt(lambda_0)) 
  #prob_event <- plogis(-2 + .3*(X1)/sqrt(lambda_0)) * plogis(interval_length)
  #Y1 <- rbinom(n_packs, size=1, prob=prob_event)
  Y1 <- rep(1,n_packs) 
  # P1 <- rbinom(n_packs, size=1, prob=.2)
  
  current_dat <- bind_cols(X1=X1, Y1=Y1)
  current_dat <- get_W_at_k_trial(1, trial_start, current_dat, 
                                  n_packs, interval_length)
 # glimpse(current_dat)
  #current_dat <- bind_col(X1=X1, Y1=Y1, W1=W1, P1=P1)
  # current_dat <- bind_cols(X1=X1, Y1=Y1, W1=W1)

  for (i in 1:K) {
    # cat("i=",i)
    current_dat <- get_treatment_at_k(i, 
                                      current_dat,
                                      n_packs,
                                      interval_length,
                                      intervention=intervention)

    current_dat <- get_X_at_k(i+1, current_dat, n_packs)
    current_dat <- get_W_at_k_trial(i+1, trial_start+i, current_dat, 
                                    n_packs, interval_length)
    current_dat <- get_outcome_at_k(i+1, current_dat, n_packs, interval_length)
    
  }
  
  current_dat <- get_treatment_at_k(K+1, current_dat,
                                      n_packs,
                                      interval_length,
                                      intervention=intervention)

  # incorporate right truncation
  current_dat <- current_dat %>%
    rowwise() %>%
    mutate(Y_sum = sum(c_across(starts_with("Y")), 
                       na.rm = TRUE)) %>%
    ungroup() %>%
    filter(Y_sum >0) %>%
    select(-Y_sum)

  return(current_dat)

}

# run_trial(weeks=16, n_packs=5)




```

# Generate Counterfactuals


```{r}

get_counterfactual_mean_updated <- function(
    weeks, n_packs, 
    interval_length=2,
    intervention,
    n_trials=5000) {
  
  dat <- map_df(1:n_trials, ~run_trial(weeks=weeks,
                                       n_packs=n_packs,
                                       interval_length,intervention))
  
  counterfactual_mean <- dat %>%
    select(contains("Y")) %>%
    select(-c(Y1)) %>%
    rowSums() %>%
    mean()
  
  return(counterfactual_mean)
  
}
```


```{r counterfactual-mean-estimates}

#---------------------------------------------------------------------------------
# always treat at __ weeks, don't treat __ or ___, natural treatment otherwise
#---------------------------------------------------------------------------------
d_always_treat_at_two_weeks_natural <- function(dat, time_point, current_a=NULL) {
  
  if(time_point == 1) {
    A1_new=rep(1, nrow(dat))
  }else if (time_point %in% c(2,3)) {
    A1_new=rep(0, nrow(dat))
  } else {
    A1_new = current_a
  }
  return(tibble(A1=A1_new))
}
d_always_treat_at_four_weeks_natural <- function(dat, time_point, current_a=NULL) {
  
  if(time_point == 2) {
    A1_new=rep(1, nrow(dat))
  }else if (time_point %in% c(1,3)) {
    A1_new=rep(0, nrow(dat))
  } else {
    A1_new = current_a
  }
  return(tibble(A1=A1_new))
}
d_always_treat_at_six_weeks_natural <- function(dat, time_point, current_a=NULL) {
  
  if(time_point == 3) {
    A1_new=rep(1, nrow(dat))
  }else if (time_point %in% c(1,2)) {
    A1_new=rep(0, nrow(dat))
  } else {
    A1_new = current_a
  }
  return(tibble(A1=A1_new))
}
dont_treat_within_6_weeks_after_dep_event <- function(dat, time_point, current_a) {
  
  if (time_point %in% c(1,2,3)) {
    A1_new = rep(0, nrow(dat))
  } else{
    A1_new =current_a
  }

  return(tibble(A1=A1_new))
}

#-----------------------------------------------------------
# never treat within 4 months of depredation event 
#-----------------------------------------------------------
never_treat_within_4_months <- function(dat, time_point, current_a=NULL) {
     
  return(tibble(A1=rep(0, nrow(dat))))
  
}

#------------------------------------------------------------------
# always treat at two weeks, don't treat within 4 months otherwise  
#------------------------------------------------------------------
d_always_treat_at_two_weeks <- function(dat, time_point, current_a=NULL) {
  
  A1_new = ifelse(time_point==1, 1, 0)

  return(tibble(A1=A1_new))
  
}

#------------------------------------------------------------------
# always treat at four weeks, don't treat within 4 months otherwise  
#------------------------------------------------------------------
d_always_treat_at_four_weeks <- function(dat, time_point, current_a=NULL) {
  
  A1_new = ifelse(time_point==2, 1, 0)
    
  return(tibble(A1=A1_new))
  
}

#------------------------------------------------------------------
# always treat at six weeks, don't treat within 4 months otherwise  
#------------------------------------------------------------------
d_always_treat_at_six_weeks <- function(dat, time_point, current_a=NULL) {
  
  A1_new = ifelse(time_point==3, 1, 0)
    
  return(tibble(A1=A1_new))
  
}


#------------------
# never treat
#------------------
d_never_treat <- function(dat, time_point, current_a=NULL) {

  return(tibble(A1=rep(0,nrow(dat))))
                
}


```

```{r counterfactuals-natural,eval=FALSE}

treat_at_2_then_natural <- get_counterfactual_mean_updated(
  16, n_packs=5,interval_length= 2, d_always_treat_at_two_weeks_natural)

treat_at_4_then_natural <-  get_counterfactual_mean_updated(
  16, n_packs=5,interval_length= 2, d_always_treat_at_four_weeks_natural)

treat_at_6_then_natural <-  get_counterfactual_mean_updated(
  16, n_packs=5,interval_length= 2, d_always_treat_at_six_weeks_natural)

dont_treat_6_weeks_then_natural <- get_counterfactual_mean_updated(
  16, n_packs=5,interval_length= 2, dont_treat_within_6_weeks_after_dep_event)


cat("A1=1,A2=0,A3=0, natural", "\n")
treat_at_2_then_natural/dont_treat_6_weeks_then_natural
cat("A1=0,A2=1,A3=0, natural", "\n")
treat_at_4_then_natural/dont_treat_6_weeks_then_natural
cat("A1=0,A2=0,A3=1, natural","\n")
treat_at_6_then_natural/dont_treat_6_weeks_then_natural


```


```{r counterfactuals-never-treat,eval=FALSE}

treat_only_at_2 <- get_counterfactual_mean_updated(
  16, n_packs=5,interval_length= 2, d_always_treat_at_two_weeks)

treat_only_at_4 <- get_counterfactual_mean_updated(
  16, n_packs=5,interval_length= 2, d_always_treat_at_four_weeks)

treat_only_at_6 <- get_counterfactual_mean_updated(
  16, n_packs=5, interval_length= 2, d_always_treat_at_six_weeks)

never_treat <-get_counterfactual_mean_updated(
  16, n_packs=5, interval_length= 2, d_never_treat)


cat("A1=1,A2=0,A3=0, never treat", "\n")
treat_only_at_2/never_treat
cat("A1=0,A2=1,A3=0, never treat", "\n")
treat_only_at_4/never_treat
cat("A1=0,A2=0,A3=1, never treat","\n")
treat_only_at_6/never_treat


```


```{r,eval=FALSE}
saveRDS(list(treat_2_natural = treat_at_2_then_natural/dont_treat_6_weeks_then_natural,
              treat_4_natural = treat_at_4_then_natural/dont_treat_6_weeks_then_natural,
              treat_6_natural = treat_at_6_then_natural/dont_treat_6_weeks_then_natural,
             only_2 = treat_only_at_2/never_treat,
             only_4 = treat_only_at_4/never_treat,
             only_6 = treat_only_at_6/never_treat
              ), here("data/truth_trials.RDS"))




```

```{r counterfactual-results, results='asis'}

truth <- readRDS(here("data/truth_trials.RDS"))

cat("A1=1,A2=0,A3=0, natural", "\n")
truth$treat_2_natural
cat("A1=0,A2=1,A3=0, natural", "\n")
truth$treat_4_natural
cat("A1=0,A2=0,A3=1, natural","\n")
truth$treat_6_natural

cat("A1=1,A2=0,A3=0, never treat", "\n")
truth$only_2
cat("A1=0,A2=1,A3=0, never treat", "\n")
truth$only_4
cat("A1=0,A2=0,A3=1, never treat","\n")
truth$only_6

```


# Simulate Data 

```{r run-simulation}

# for simplicity, suppose study start is in January 
# intervention must be a function that outputs A1, A2 (assigned treatments) 
# takes in the natural value of treatment (so can be a shift intervention)
run_simulation <- function(years=5, n_packs=30,
                           interval_length=8, 
                           intervention=NULL) {
  
  # 8 week intervals
  K <- round((years*52)/interval_length)
  
  #----------------------------------------------------------------
  # Baseline covariates: number of wolves in pack at study start 
  #----------------------------------------------------------------
  lambda_0 <- 8 
  X1 <- rpois(n_packs, lambda_0)
  # winter -> cows close to home -> safer 
  W1 <- rep(1, n_packs)
  
  # first depredation event
  # prob_event <- plogis(-4 + .3*(L0)/sqrt(lambda_0)) 
  prob_event <- plogis(-2 + .3*(X1)/sqrt(lambda_0)) * plogis(interval_length)
  Y1 <- rbinom(n_packs, size=1, prob=prob_event)
  # P1 <- rbinom(n_packs, size=1, prob=.2)
  
  #current_dat <- bind_cols(X1=X1, Y1=Y1, W1=W1, P1=P1)
  current_dat <- bind_cols(X1=X1, Y1=Y1, W1=W1)

  for (i in 1:K) {
    # cat("i=",i)
    current_dat <- get_treatment_at_k(i, 
                                      current_dat,
                                      n_packs,
                                      interval_length,
                                      intervention=intervention)

    current_dat <- get_X_at_k(i+1, current_dat, n_packs)
    current_dat <- get_W_at_k(i+1, current_dat, n_packs, interval_length)
    current_dat <- get_outcome_at_k(i+1, current_dat, n_packs, interval_length)
    
  }
  
  current_dat <- get_treatment_at_k(K+1, current_dat,
                                      n_packs,
                                      interval_length,
                                      intervention=intervention)

  # incorporate right truncation
  current_dat <- current_dat %>%
    rowwise() %>%
    mutate(Y_sum = sum(c_across(starts_with("Y")), 
                       na.rm = TRUE)) %>%
    ungroup() %>%
    filter(Y_sum >0) %>%
    select(-Y_sum)

  return(current_dat)

}


```

```{r get-biweekly-dat, class.source="fold-show",eval=FALSE}

# biweekly
# current_dat <- run_simulation(years=10, 
#                               n_packs=55, 
#                               interval_length=2) %>%
#   mutate(id = row_number())

# for testing -- biweekly
current_dat <- run_simulation(years=10, 
                              n_packs=2000, 
                              interval_length=2) %>%
  mutate(id = row_number())




```

```{r get-trial-dat,eval=FALSE}

df <- map_df(1:1000, ~run_trial(weeks=16,
                                       n_packs=5,
                                       interval_length=2,
                                intervention=NULL) %>%
               mutate(id = sample(size=5, 1:50, replace=FALSE)))
  
df <- df %>%
  rename_with(.cols=contains("A"), ~gsub("_1", "", .x)) %>%
  select(-c(A9,W9,X9))


saveRDS(df, here("data/df_trial.RDS"))

```



```{r}

```


```{r,eval=FALSE}

test <- current_dat %>%
    rowwise() %>%
    mutate(Y_sum = sum(c_across(starts_with("Y")), 
                       na.rm = TRUE),
              A_sum = sum(c_across(matches("A*_1")), 
                       na.rm = TRUE)) 
test %>%
  ggplot(aes(x=Y_sum)) +
  geom_histogram()

test %>%
  ggplot(aes(x=A_sum)) +
  geom_histogram()


```

  
```{r get-counterfactuals,eval=FALSE}

get_counterfactual_mean_new <- function(
    years, n_packs, 
    interval_length=2,
    intervention) {
  
  dat <- run_simulation(
    years=years, 
    n_packs=n_packs, 
    interval_length=interval_length,
    intervention = intervention) 
  
  counterfactual_mean <- get_mean_4_months_after_dep_event(dat)
  
  return(counterfactual_mean)
  
}

# modify to make comparable -- i.e. don't treat within 6 weeks,
# then follow natural course of treatment 
# also add never treat contrast 


get_mean_4_months_after_dep_event <- function(dat) {
  
  # 1. pick out the Y columns (adjust the pattern if needed)
  Ycols <- dat %>%
    select(contains("Y")) %>%
    colnames()
  
  Ymat  <- as.matrix(dat[ , Ycols])
  nT    <- ncol(Ymat)
  
  # new matrix to store "sum of next 16 weeks" (8 2-week intervals)
  sum_next8 <- matrix(NA_real_, nrow = nrow(Ymat), ncol = nT)
  
  for (k in seq_len(nT-8)) {
    # last time points may have <16 weeks remaining
    end_k <- min(nT, k + 8)
    # cat("k=",k,", ", "end_k=", end_k, "\n")
    # cat("sum taken from", k+1, "to", end_k, "\n")
    if (k < nT) {
      fut_sum <- rowSums(Ymat[ , (k+1):end_k, drop = FALSE])
    } else {
      fut_sum <- 0
    }
    
    # only keep this sum when Y at time k is 1
    #sum_next16[ , k] <- ifelse(Ymat[ , k] == 1, fut_sum, 0)
    # or use NA instead of 0 if you prefer:
     sum_next8[ , k] <- ifelse(Ymat[ , k] == 1, fut_sum, NA)
  }
  
  sum_next8 %>%
    as.data.frame() %>% 
    pivot_longer(cols=everything()) %>%
    pull(value)%>%
    mean(na.rm=TRUE)

  
}

dont_treat_within_6_weeks_after_dep_event <- function(dat, time_point, current_a) {
  
  if(time_point > 2) {
    # if any Y_{t}, Y_{t-1}, Y_{t-2} = 1, don't treat
     y_before <- dat %>% 
       select(all_of(paste0("Y", (time_point-2):time_point))) %>%
       rowSums()
              
     A1_new = ifelse(y_before == 1, 0, current_a)

  } else if (time_point==2) {
     y_before <- dat %>% 
       select(all_of(paste0("Y", (time_point-1):time_point))) %>%
       rowSums()
     A1_new = ifelse(y_before == 1, 0, current_a)
  } else {
    y_before <- dat %>% 
       select(all_of(paste0("Y", time_point))) %>%
       rowSums()
     A1_new = ifelse(y_before == 1, 0, current_a)
  }
  return(tibble(A1=A1_new))
}

#------------------------------------------------------------------
# always treat at two weeks, don't treat within 4 months otherwise  
#------------------------------------------------------------------
d_always_treat_at_two_weeks <- function(dat, time_point, current_a=NULL) {
  
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     
     # only modify within our treatment population, those who had an event
     # within 4 months
     y_within_4_months <- dat %>% 
       select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
       rowSums()
    
     treat_otherwise <- ifelse(y_within_4_months, 0, current_a)
     
     A1_new = ifelse(y_before == 1, 1, treat_otherwise)

  return(tibble(A1=A1_new))
  
}


#------------------------------------------------------------------
# always treat at two weeks, natural otherwise  
#------------------------------------------------------------------
d_always_treat_at_two_weeks_natural_no_mod_2_to_6 <- function(dat, time_point, current_a=NULL) {
  
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     
     # only modify within our treatment population, those who had an event
     # within 4 months
     # y_within_4_months <- dat %>% 
     #   select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
     #   rowSums()
    
     # treat_otherwise <- ifelse(y_within_4_months, 0, current_a)
     
     A1_new = ifelse(y_before == 1, 1, current_a)

  return(tibble(A1=A1_new))
  
}

#------------------------------------------------------------------
# always treat at two weeks, natural otherwise  
#------------------------------------------------------------------
d_dont_treat_at_two_weeks_natural_no_mod_2_to_6 <- function(dat, time_point, current_a=NULL) {
  
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     
     # only modify within our treatment population, those who had an event
     # within 4 months
     # y_within_4_months <- dat %>% 
     #   select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
     #   rowSums()
    
     # treat_otherwise <- ifelse(y_within_4_months, 0, current_a)
     
     A1_new = ifelse(y_before == 1, 0, current_a)

  return(tibble(A1=A1_new))
  
}


#---------------------------------------------------------------------------------
# always treat at two weeks, don't treat 2-4 or 4-6, natural treatment otherwise
#---------------------------------------------------------------------------------
d_always_treat_at_two_weeks_natural <- function(dat, time_point, current_a=NULL) {
  
  if(time_point > 2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     y_biweek_lag2 <- dat %>% 
       pull(paste0("Y", time_point-2))
     
     # treat when Y at same time point is 1 (Y1=1 => A1=1)
     # don't treat if Y_{t-1} is 1 (this implies Y1=1 => A2=0)
     # don't treat if Y_{t-2} is 1 (this implies Y1=1 => A3=0)

     A1_new = case_when(y_before == 1 ~ 1,
                        y_biweek_lag1 == 1 ~ 0,
                        y_biweek_lag2 == 1 ~ 0,
                        TRUE ~ current_a)

  } else if(time_point ==2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     
     A1_new = case_when(y_before == 1 ~ 1,
                        y_biweek_lag1 == 1 ~ 0,
                        TRUE ~ current_a)
    
  } else if(time_point ==1) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
  
     A1_new = case_when(y_before == 1 ~ 1,
                        TRUE ~ current_a)
    
  }

  return(tibble(A1=A1_new))
  
}


d_always_treat_at_four_weeks_natural <- function(dat, time_point, current_a=NULL) {
  
  if(time_point > 2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     y_biweek_lag2 <- dat %>% 
       pull(paste0("Y", time_point-2))
     
     # treat when Y at same time point is 1 (Y1=1 => A1=1)
     # don't treat if Y_{t-1} is 1 (this implies Y1=1 => A2=0)
     # don't treat if Y_{t-2} is 1 (this implies Y1=1 => A3=0)

     A1_new = case_when(y_before == 1 ~ 0,
                        y_biweek_lag1 == 1 ~ 1,
                        y_biweek_lag2 == 1 ~ 0,
                        TRUE ~ current_a)

  } else if(time_point ==2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     
     A1_new = case_when(y_before == 1 ~ 0,
                        y_biweek_lag1 == 1 ~ 0,
                        TRUE ~ current_a)
    
  } else if(time_point ==1) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
  
     A1_new = case_when(y_before == 1 ~ 0,
                        TRUE ~ current_a)
    
  }

  return(tibble(A1=A1_new))
  
}


d_always_treat_at_six_weeks_natural <- function(dat, time_point, current_a=NULL) {
  
  if(time_point > 2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     y_biweek_lag2 <- dat %>% 
       pull(paste0("Y", time_point-2))
     
     # treat when Y at same time point is 1 (Y1=1 => A1=1)
     # don't treat if Y_{t-1} is 1 (this implies Y1=1 => A2=0)
     # don't treat if Y_{t-2} is 1 (this implies Y1=1 => A3=0)

     A1_new = case_when(y_before == 1 ~ 0,
                        y_biweek_lag1 == 1 ~ 0,
                        y_biweek_lag2 == 1 ~ 1,
                        TRUE ~ current_a)

  } else if(time_point ==2) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
     y_biweek_lag1 <- dat %>% 
       pull(paste0("Y", time_point-1))
     
     A1_new = case_when(y_before == 1 ~ 0,
                        y_biweek_lag1 == 0 ~ 0,
                        TRUE ~ current_a)
    
  } else if(time_point ==1) {
    
     y_before <- dat %>% 
       pull(paste0("Y", time_point))
  
     A1_new = case_when(y_before == 1 ~ 0,
                        TRUE ~ current_a)
    
  }

  return(tibble(A1=A1_new))
  
}

#-----------------------------------------------------------
# never treat within 4 months of depredation event 
#-----------------------------------------------------------
never_treat_within_4_months <- function(dat, time_point, current_a=NULL) {
  
    y_within_4_months <- dat %>% 
       select(all_of(paste0("Y", max(1,time_point-7):time_point))) %>%
       rowSums()
     
    A1_new <- ifelse(y_within_4_months, 0, current_a)
     
  return(tibble(A1=A1_new))
  
}

d_never_treat <- function(dat, time_point, current_a=NULL) {

  return(tibble(A1=rep(0,nrow(dat))))
                
}

N_PACKS <- 1e3 
N_YEARS <- 10 

# identity <- get_counterfactual_mean_new(N_YEARS, N_PACKS, 2, NULL)
# 
# never_treat <- get_counterfactual_mean_new(
#   N_YEARS, N_PACKS, 2, never_treat_within_4_months)
# 
# only_treat_two_weeks <- get_counterfactual_mean_new(
#   N_YEARS, N_PACKS, 2, d_always_treat_at_two_weeks)
# 

# treat at 2 then natural
# treat_two_weeks_then_natural_no_modification_2_to_6 <- get_counterfactual_mean_new(
#   N_YEARS, N_PACKS, 2, d_always_treat_at_two_weeks_natural_no_mod_2_to_6)
# 
# dont_treat_two_weeks_then_natural_no_modification_2_to_6 <- get_counterfactual_mean_new(
#   N_YEARS, N_PACKS, 2,  d_dont_treat_at_two_weeks_natural_no_mod_2_to_6)


# cat("only modifying A1, leaving all others natural",
#     treat_two_weeks_then_natural_no_modification_2_to_6/dont_treat_two_weeks_then_natural_no_modification_2_to_6)

# treat at 2, then don't 2-6
treat_at_2_then_natural <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, d_always_treat_at_two_weeks_natural)

treat_at_4_then_natural <-  get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, d_always_treat_at_four_weeks_natural)

treat_at_6_then_natural <-  get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, d_always_treat_at_six_weeks_natural)

dont_treat_6_weeks_then_natural <- get_counterfactual_mean_new(
  N_YEARS, N_PACKS, 2, dont_treat_within_6_weeks_after_dep_event)


cat("A1=1,A2=0,A3=0, natural", "\n")
treat_at_2_then_natural/dont_treat_6_weeks_then_natural
cat("A1=0,A2=1,A3=0, natural", "\n")
treat_at_4_then_natural/dont_treat_6_weeks_then_natural
cat("A1=0,A2=0,A3=1, natural","\n")
treat_at_6_then_natural/dont_treat_6_weeks_then_natural



```

```{r,eval=FALSE}
# only_treat_two_weeks/never_treat
# only_treat_two_weeks/identity

effect_natural=treat_two_weeks_then_natural/dont_treat_6_weeks_then_natural
cat("Treat at time 1, don't treat at times 2 or 3, then natural", effect_natural, "\n")

effect_no_treat=only_treat_two_weeks/never_treat 
cat("Treat at time 1, don't treat at times 2-8", effect_no_treat, "\n")


truth <- list(effect_natural = effect_natural,
              effect_no_treat = effect_no_treat)

saveRDS(truth, here::here('data/truth_from_counterfactuals.RDS'))


```





# Modeling 

```{r reformat-dat-into-trial-format}

format_dat <- function(current_dat) {
  delta <- 8
  # 4 months = 4*4/2 = 8 2-week intervals
  confound_window <- 0
  
  n_time_points <- current_dat %>%
    select(contains("Y")) %>% 
    ncol()
  
  current_dat <- current_dat %>%
    mutate(id=row_number())
  
  row_list <- list()
  seq_names <- 1:(1+confound_window+delta-1)
  
  for (i in (1+confound_window):(n_time_points-delta)) {
    
    for (j in 1:nrow(current_dat)) {
  
      if(current_dat[j, paste0("Y",i)]==1) {
        window <- (i-confound_window):(i+delta-1)
        
        row <- current_dat[j,] %>%
          select(all_of(paste0("Y", window)), 
                 all_of(paste0("X", window)),
                 all_of(paste0("W", window)),
                 all_of(paste0("A", window, "_1"))) %>%
          mutate(id = j)
        
        colnames(row) <- c(paste0("Y",seq_names),
                           paste0("X",seq_names),
                           paste0("W", seq_names),
                           paste0("A", seq_names),
                           "id")
        
        row_list <- c(row_list,list(row))
          
        }
      }
      
    }

  df <- bind_rows(row_list)
  return(df)

}

```

```{r reformat-current-dat-into-trial-format,eval=FALSE}

#----------------------------------
# reformat data into trial format 
#----------------------------------

df <- format_dat(current_dat)

saveRDS(df, here('data/long_df.RDS'))

# delta <- 8
# 4 months = 4*4/2 = 8 2-week intervals

```

```{r ipw-and-modeling-functions}

library(SuperLearner)
confound_window <- 0

#-----------------------------------
# IPW weighting functions 
#-----------------------------------
get_weight_by_k_superlearner <- function(k,dat) {
  
  confound_end <- confound_window+k
  
  # only A_t for t < trial start included as confounders
  treat_end <- confound_window+k-1
  
  confound_hist<- paste0(
                       c(
                       # paste0("Z", 1:confound_end),
                        paste0("W", 1:confound_end),
                       # paste0("Y", 2:confound_end),
                        paste0("X", 1:confound_end)
                        ),
                        # paste0("A", 1:treat_end)),
                        collapse="+")
  confound_hist <- ifelse(k==1, "X1+W1", confound_hist)
  
  
  treat_hist <- ifelse(k==1, "1", 
                       paste0(
                         paste0("A",
                                (confound_window+1):(k-1), collapse="+")))
 
  hist <- ifelse(k==1,confound_hist,
                 paste0(confound_hist, "+", treat_hist))
  # hist <- paste0(confound_hist, "+", treat_hist)
  treat_name <- paste0("A", k)

  mod_a1_num <- glm(as.formula(paste0(treat_name, "~", treat_hist) ),
                data=dat, family=binomial)

  
  if(k>1) {
    mod_a1_num <- get_mod_superlearner(treat_name, treat_hist, dat)
    
  }                     
  
  mod_a1_denom <-get_mod_superlearner(treat_name,hist,dat)
  
  cat("k=",k,"\n")
  cat("Numerator=",paste0(treat_name, "~", treat_hist), "\n")
  cat("Denominator=",paste0(treat_name, "~",
                               hist), "\n")

  treat_name <- paste0("A", k)
  
  pred <- dat %>%
    mutate(pred_num =ifelse(k>1, mod_a1_num$SL.predict,
                            predict(mod_a1_num,
                                    type="response")),
                            
           pred_num = ifelse(dat[[treat_name]] == 1,
                         pred_num,
                         1-pred_num),
           pred_denom = mod_a1_denom$SL.predict,
           pred_denom = ifelse(dat[[treat_name]]==1,
                               pred_denom,
                               1-pred_denom))

  w <- pred$pred_num / pred$pred_denom
  return(w)
}


get_weight_by_k <- function(k, dat, quiet=FALSE) {
  
  confound_end <- confound_window+k
  
  # only A_t for t < trial start included as confounders
  treat_end <- confound_window+k-1
  
  confound_hist<- paste0(
                       c(
                       # paste0("Z", 1:confound_end),
                        paste0("W", 1:confound_end),
                        paste0("Y", 2:confound_end),
                        paste0("X", 1:confound_end)
                        ),
                        # paste0("A", 1:treat_end)),
                        collapse="+")

  
  confound_hist <- ifelse(k==1, "X1+W1", confound_hist)
  
  
  treat_hist <- ifelse(k==1, "1", 
                       paste0(
                         paste0("A",
                                (confound_window+1):(k-1), collapse="+")))
 
  hist <- ifelse(k==1,confound_hist,
                 paste0(confound_hist, "+", treat_hist))
  # hist <- paste0(confound_hist, "+", treat_hist)
  treat_name <- paste0("A", k)

  mod_a1_num <- glm(as.formula(paste0(treat_name, "~", treat_hist) ),
                data=dat, family=binomial)

  
  # if(k>1) {
  #   mod_a1_num <- get_mod_superlearner(treat_name, treat_hist, dat)
  #   
  # }                     
  
  mod_a1_denom <- glm(as.formula(paste0(treat_name, "~",
                                hist) ),
                data=dat, family=binomial)

  # mod_a1_denom <-get_mod_superlearner(treat_name,hist,dat)
  
  
  if (!quiet) {
    cat("k=",k,"\n")
    cat("Numerator=",paste0(treat_name, "~", treat_hist), "\n")
    cat("Denominator=",paste0(treat_name, "~",
                                 hist), "\n")

  }
  
  treat_name <- paste0("A", k)
  
  pred <- dat %>%
    mutate(pred_num = predict(mod_a1_num,
                          type="response",
               newdata=dat),
           pred_num = ifelse(dat[[treat_name]] == 1,
                         pred_num,
                         1-pred_num),
           pred_denom = predict(mod_a1_denom,
                          type="response",
               newdata=dat),
           pred_denom = ifelse(dat[[treat_name]]==1,
                               pred_denom,
                               1-pred_denom))
 
  w <- pred$pred_num / pred$pred_denom
  return(w)
}


get_weights <- function(delta, dat, superlearner=FALSE, quiet=FALSE) {
  
  if(!superlearner) {
     final_w <- map(1:delta, ~get_weight_by_k(k=.x,
                                      dat=dat,
                                      quiet=quiet)) %>%
    reduce(`*`)
  }
  else {
      final_w <- map(1:delta, ~get_weight_by_k_superlearner(k=.x,
                                      dat=dat)) %>%
       reduce(`*`)
  }
 
  
  
  final_w_trunc <- ifelse(final_w < quantile(final_w,.005), 
                          quantile(final_w,.01), final_w)
  
  final_w_trunc <- ifelse(final_w > quantile(final_w,.995),
                          quantile(final_w,.99), final_w_trunc)

  return(final_w_trunc)
  
}

get_mod_superlearner <- function(treat_name, treat_hist, dat) {
  
   # Define learner library (you can tweak this)
  SL.library <- c(
    "SL.mean",       # intercept-only
    "SL.glm",        # main-effects logistic regression
  #  "SL.glmnet",     # penalized regression
    "SL.randomForest" # random forest (requires randomForest)
  )
  
  set.seed(123)
  covars <- strsplit(treat_hist, "+",fixed=TRUE) %>% unlist()
  # cat(covars)
  
  X_input <- dat %>%
    select(all_of(covars))
  
  # glimpse(X_input)
  Y_input <- dat %>% pull(treat_name)
  
  sl_fit <- SuperLearner(
    Y      = (Y_input),
    X      = as.data.frame(X_input),
    family = binomial(),   # binary outcome => logit link
    SL.library = SL.library,
    cvControl = list(
      V = 2,               # 5-fold cross-validation
      stratifyCV = TRUE
    ))
  
}


get_treatment_effect <- function(dat, delta, form, superlearner=FALSE, quiet=FALSE) {
  
  w <- get_weights(delta=delta, dat=dat, superlearner=superlearner, quiet=quiet)
  dat$ipw <- w
  
  svy_design <- svydesign(
    ids = ~id,             # clustering variable (person-level)
    weights = ~ipw,        # your IPTW/IPCW weight
    data = dat
  )
  
  # if(only){
  #   var <- paste0(model_var, "_only")
  # } else{
  #   var <- model_var
  # }
  
  model <- survey::svyglm(as.formula(form),
                  design=svy_design, family=poisson())
  if(!quiet) cat("model is", form, "\n")
  ci <- confint(model) %>% 
      as.data.frame() %>%
     rename(lower=1, upper=2) %>%
    slice(-1)
     
  coef(model)[-1] %>%
    as_tibble(rownames="var") %>%
    bind_cols(ci) %>%
    mutate(across(where(is.numeric), exp))
  
}


```


```{r}

df <- readRDS(here("data/df_trial.RDS"))

outcome <- df %>%
     select(-Y1) %>%
     select(contains("Y")) %>%
     rowSums() 
df$outcome <- outcome 

```

```{r add-factors-function}

add_factors <- function(dat) {
  
  outcome <- dat %>%
     select(-Y1) %>%
     select(contains("Y")) %>%
     rowSums() 
  dat$outcome <- outcome 
  
  dat <- dat %>%
      mutate(A1_only = A1==1 & A2==0 & A3==0,
             A2_only = A1==0 & A2==1 & A3==0,
             A3_only = A1==0 & A2==0 & A3==1,
             never_treat = A1==0 & A2==0 & A3==0,
             A1_never_treat_only = A1==1 & A2==0 & A3==0
             & A4==0 & A5 ==0 & A6== 0 & A7 == 0 & A8 == 0,
            A2_never_treat_only = A1==0 & A2==1 & A3==0
             & A4==0 & A5 ==0 & A6== 0 & A7 == 0 & A8 ==0,
            A3_never_treat_only = A1==0 & A2==0 & A3==1
             & A4==0 & A5 ==0 & A6== 0 & A7 == 0 & A8==0,
            never_treat_whole_period = A1==0 & A2==0 & A3==0
             & A4==0 & A5 ==0 & A6== 0 & A7 == 0 & A8==0)
  
  dat <- dat %>%
    mutate(treatment_factor = case_when(
      A1_only ==1 ~ "A1_only",
      A2_only ==1 ~ "A2_only",
      A3_only ==1 ~ "A3_only",
      never_treat==1~"never_treat",
      TRUE~"other")) %>%
      mutate(treatment_factor = factor(treatment_factor,
                                       levels=c("never_treat",
                                                "A1_only",
                                                "A2_only",
                                                "A3_only",
                                                "other")),
             treatment_factor_never_treat = case_when(
                 A1_never_treat_only ==1 ~ "A1_only",
                A2_never_treat_only ==1 ~ "A2_only",
                A3_never_treat_only ==1 ~ "A3_only",
                never_treat_whole_period==1~"never_treat",
                TRUE~ "other"
             ),
             treatment_factor_never_treat = factor(treatment_factor_never_treat,
                                       levels=c("never_treat",
                                                "A1_only",
                                                "A2_only",
                                                "A3_only",
                                                "other")))
  
  return(dat)


}

```


```{r, warning=FALSE}

df <- add_factors(df)

cat("Follow natural treatment after week 6")

get_treatment_effect(df, delta=3, form="outcome~treatment_factor",
                     superlearner=FALSE) 

cat("Never treat after week 6")
get_treatment_effect(df, delta=8, form="outcome~treatment_factor_never_treat",
                     superlearner=FALSE) 

```

# Run Simulation

```{r run-model-many-times}

results <- map_df(1:200, ~{
  
    dat <- map_df(1:300, ~run_trial(weeks=16,
                                           n_packs=2,
                                           interval_length=2,
                                    intervention=NULL) %>%
                   mutate(id = sample(size=2, 1:40, replace=FALSE)))
      
    dat <- dat %>%
      rename_with(.cols=contains("A"), ~gsub("_1", "", .x)) %>%
      select(-c(A9,W9,X9))
    
    dat <- add_factors(dat)
    
    res1 <- get_treatment_effect(dat, delta=3, form="outcome~treatment_factor",
                     superlearner=FALSE, quiet=TRUE) %>%
      mutate(source="natural")
    res2 <-  get_treatment_effect(dat, delta=3, form="outcome~treatment_factor_never_treat",
                     superlearner=FALSE, quiet=TRUE) %>%
      mutate(source="never treat")
    
    bind_rows(res1, res2)
    
})

saveRDS(results, here("data/model_results.RDS"))

```


```{r, fig.width=8, fig.height=6}

results <- readRDS(here("data/model_results.RDS"))

truth <- readRDS(here("data/truth_trials.RDS"))



truth_df <- as_tibble(truth) %>%
  pivot_longer(cols=everything(),values_to="truth") %>%
  mutate(source = ifelse(grepl("natural", name), 
                         "natural", "never treat"),
         var=case_when(
           grepl("2", name) ~ "A1_only",
           grepl("4", name) ~ "A2_only",
           grepl("6", name) ~ "A3_only"
         ))

results <- results %>%
  filter(!grepl("other", var)) %>%
  mutate(var = gsub("treatment_factor|_never_treat", "", var)) 


coverage <- results %>%
  left_join(truth_df %>% select(-name)) %>%
  mutate(contained=(truth >= lower & truth <= upper)) %>%
  group_by(var,source) %>%
  summarize(coverage=sum(contained)/n())
  

results %>%
  ggplot(aes(x=value)) +
  geom_histogram(bins=22) +
  geom_vline(aes(xintercept=truth, color="True Value"),
             data=truth_df,
             linetype=2) +
  facet_grid(var~source,
             labeller = labeller(
      var = c(
        A1_only = "A1 = 1, A2 = 0, A3 = 0",
        A2_only = "A1 = 0, A2 = 1, A3 = 0",
        A3_only = "A1 = 0, A2 = 0, A3 = 1"
      ))) +
  theme_c(strip.text=element_text(
    size=14, color="white",  face="bold",
    margin = margin(t = 8, r = 8, b = 8, l = 8)),
    legend.position="top",
    legend.text=element_text(size=14))  +
  labs(color="") +
  scale_x_continuous(n.breaks=8)

ggsave(here("figures/simulation_results.jpeg"))

coverage

```




